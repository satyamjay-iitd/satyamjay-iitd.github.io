{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Curriculum Vitae","text":""},{"location":"#profile","title":"Profile","text":"<ul> <li>Pursuing PhD in Distributed systems under the guidance of Prof. Abhilash Jindal.</li> </ul>"},{"location":"#skills","title":"Skills","text":"<ul> <li> <p>Programming Languages:- Rust, Python, Java, C, C++</p> </li> <li> <p>Systems Building Skills:- Http/Grpc/TCP Backend</p> </li> <li> <p>Data:- SQL, Flink, Pandas, Matplotlib</p> </li> <li> <p>ML:- Deploying/Training of ML models for online inference, using technologies like</p> </li> <li> <p>System Management:- Linux, Docker, Aws, Git</p> </li> </ul>"},{"location":"#employment-history","title":"Employment History","text":"<p>ML Engineer - Pepperfy.com Mumbai, 2022 - 2023</p> <p>Projects:-</p> <ul> <li>User interaction driven dynamic product ranking system</li> <li>Image search</li> </ul> <p>Software Engineer Intern IBM Bengaluru, 2019(6 months)</p> <p>Project:-</p> <ul> <li>Java log visualization tool</li> </ul>"},{"location":"#publications","title":"Publications","text":"<p>None</p>"},{"location":"#education","title":"Education","text":"<p>PhD, IIT Delhi Delhi, 2023 \u2013</p> <p>M.Tech in Computer Science, IIT Delhi Delhi, 2020 \u2013 2022</p> <ul> <li>Built Autonomous vehicle simulation using Unity and Carla as Major Project</li> </ul> <p>B.Tech in Computer Science, Peoples University, Bhopal Bhopal, 2016 \u2013 2020</p> <ul> <li>Built Automatic attendance system using image search as Major Project</li> </ul>"},{"location":"#personal-details","title":"Personal Details","text":"<ul> <li>Location: IIT Delhi</li> <li>Linkedin: Satyam Jay</li> <li>Github: satyamjay-iitd</li> <li></li> </ul> Github Contributions"},{"location":"contact/","title":"Contact","text":"<ul> <li> <p>Email: </p> <p>satyamj@sit.iitd.ac.in satyamjay030@gmail.com </p> </li> <li> <p>Location: </p> <p>Cloud Lab (411), SIT, IIT Delhi  </p> </li> </ul>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/12/21/my-first-rust-macro/","title":"My first Rust <code>macro</code>.","text":"","tags":["rust"]},{"location":"blog/2024/12/21/my-first-rust-macro/#background","title":"Background","text":"<p>I am new to Rust programming, and currently working on my first large rust project. As part of my research we are building a data streaming framework(will be released as OSS after the paper is published). In this system there are different types of messages that can be passed between different componenets of the system.</p> <p>For example:- Message<pre><code>pub enum FromWorkerToCoord {\n    Done(String),\n    ReconfAck((String, Box&lt;ReconfMsg&gt;)),\n    PollTPResponse((String, RecvThrougputMsg)),\n    Handshake(String),\n}\n</code></pre></p> <p>For each such message we had to write a <code>Codec</code>. A codec can <code>encode</code> an object to bytes that can be sent over wire, as well as <code>decode</code> bytes recieved over the wire to an object. We are using bincode for this purpose.</p> <p>A Codec implementation for the above struct looks something like this:-</p> Codec<pre><code>#[derive(Clone)]\npub struct FromWorkerToCoordCodec {\n    config: bincode::config::Configuration,\n    length_codec: tokio_util::codec::LengthDelimitedCodec,\n}\n\nimpl FromWorkerToCoordCodec {\n    pub fn new() -&gt; Self {\n        FromWorkerToCoordCodec {\n            config: bincode::config::standard(),\n            length_codec: tokio_util::codec::LengthDelimitedCodec::builder()\n                .length_field_length(4)\n                .max_frame_length(u32::MAX as usize)\n                .new_codec(),\n        }\n    }\n}\n\nimpl tokio_util::codec::Encoder&lt;FromWorkerToCoord&gt; for FromWorkerToCoordCodec {\n    type Error = std::io::Error;\n\n    fn encode(\n        &amp;mut self,\n        item: #msg_name,\n        dst: &amp;mut bytes::BytesMut,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        ...\n        }\n}\nimpl tokio_util::codec::Decoder for FromWorkerToCoordCodec {\n    type Item = FromWorkerToCoord;\n    type Error = std::io::Error;\n\n    fn decode(&amp;mut self, src: &amp;mut BytesMut) -&gt; Result&lt;Option&lt;FromWorkerToCoord&gt;, Self::Error&gt; {\n      ...\n    }\n}\n</code></pre>","tags":["rust"]},{"location":"blog/2024/12/21/my-first-rust-macro/#motivation","title":"Motivation","text":"<p>We had bunch of such messages and needed a similar Codec for all of them. And there is no difference in logic for different Codecs, they all use bincode internally, and the only difference is the Message that they are encoding/decoding. Hence there is lot of code duplication. I had heared about <code>macros</code> in rust that allows us to prevent this.</p>","tags":["rust"]},{"location":"blog/2024/12/21/my-first-rust-macro/#macros-primer","title":"Macros primer","text":"<p>A macro is a metaprogramming tool, that allows us to write code that generates code. The macro expansion happens at compile time so there is no runtime overhead.</p> <p>A very good introduction to Rust macro can be found here. The summary of the above blog is as follows:-  There are two types of macros:-</p> <ol> <li>Declarative:- Replaces the macro invocation by the code generated by the given marco. It internally uses pattern matching based logic to generate the code.</li> <li>Procedural:- Takes in an AST and generates a new AST. Since it has access to the entire AST it can use arbitrary logic to generate code.</li> </ol> Type Usecase Examples declarative Pattern matching for repetitve code <code>vec!</code>, <code>println!</code> procedural-attribute Modify functions or structs using attributes <code>#[tokio::main]</code> procedural-derive Automatic implementation of traits <code>#[derive(Clone)]</code> procedural-function Generate new functions using some parameters","tags":["rust"]},{"location":"blog/2024/12/21/my-first-rust-macro/#implementation","title":"Implementation","text":"<p>Since I had to implement <code>Encoder</code> and <code>Decoder</code> trait I went with <code>derive_macro</code>.</p> <ol> <li>Created a new crate using <code>cargo new --lib codec-derive</code></li> <li>Instructed the compiler that this library implements a procedural macro by adding the following lines in <code>Cargo.toml</code> <pre><code>[lib]\nproc-macro = true\nCreated a new crate using `cargo new --lib codec-derive`\n</code></pre> Now lets see the code. Click on the + symbol to read the explanation.</li> </ol> Entrypoint<pre><code>use proc_macro::{self, TokenStream};\nuse syn::parse_macro_input; // (1)\nuse quote::{format_ident, quote};  // (2)\n\n#[proc_macro_derive(Codec)]\npub fn codec_derive(input: TokenStream) -&gt; TokenStream {\n    let input = parse_macro_input!(input as syn::DeriveInput);  // (3)\n\n    let name: &amp;syn::Ident = &amp;input.ident;\n    let codec_name: syn::Ident = format_ident!(\"{}Codec\", name);  // (4)\n\n    let generics = &amp;input.generics;\n    // (5)\n    if generics.params.is_empty() {\n        gen_without_generic(name, codec_name)\n    } else {\n        gen_with_generic(name, codec_name)\n    }\n}\n</code></pre> <ol> <li>syn parses the TokenStream into an AST.</li> <li>quote converts AST into a TokenStream.</li> <li>Using syn library first we convert the input token stream into an AST.</li> <li>We then generate the name of the output struct as <code>{InputStructName}Codec</code>. So the name of the generated Codec struct for <code>FromWorkerToCoord</code> will be <code>FromWorkerToCoordCodec</code>.</li> <li>Codegen logic.</li> </ol> <p>Some of our messages were generic, for example:- Generic Message<pre><code>pub enum FromPeerToPeer&lt;S&gt; {\n    Handshake(String),\n    State((StateBatch&lt;S&gt;, ReconfId)),\n}\n</code></pre></p> <p>To deal with this I had to create seperate logic for messages with a generic parameter and without generic  parameter. There has to be a better way to do this, I will refactor this when I learn that.</p> <p>Now lets see the main code generation code. Codegen without generics<pre><code>fn gen_without_generic(msg_name: &amp;syn::Ident, codec_name: syn::Ident) -&gt; TokenStream {\n    #[derive(Clone)]\n    pub struct #codec_name {   // (2)\n        config: bincode::config::Configuration,\n        length_codec: tokio_util::codec::LengthDelimitedCodec,\n    }\n\n    impl #codec_name {\n        pub fn new() -&gt; Self {\n            #codec_name {\n                config: bincode::config::standard(),\n                length_codec: tokio_util::codec::LengthDelimitedCodec::builder()\n                    .length_field_length(4)\n                    .max_frame_length(u32::MAX as usize)\n                    .new_codec(),\n            }\n        }\n    }\n\n    impl tokio_util::codec::Encoder&lt;#msg_name&gt; for #codec_name {\n        type Error = std::io::Error;\n\n        fn encode(\n            &amp;mut self,\n            item: #msg_name,    // (3)\n            dst: &amp;mut bytes::BytesMut,\n        ) -&gt; Result&lt;(), Self::Error&gt; {\n            let encoded_data = bincode::encode_to_vec(&amp;item, self.config)\n                .map_err(|_| std::io::Error::new(\n                    std::io::ErrorKind::InvalidData,\n                    \"Failed to encode data\",\n                ))?;\n\n            self.length_codec\n                .encode(bytes::Bytes::from(encoded_data), dst)\n                .map_err(|_| std::io::Error::new(\n                    std::io::ErrorKind::InvalidData,\n                    \"Couldn't encode length-delimited data\",\n                ))?;\n\n                Ok(())\n            }\n    }\n    impl tokio_util::codec::Decoder for #codec_name {\n        type Item = #msg_name;\n        type Error = std::io::Error;\n\n        fn decode(&amp;mut self, src: &amp;mut BytesMut) -&gt; Result&lt;Option&lt;#msg_name&gt;, Self::Error&gt; {\n            let frame = match self.length_codec.decode(src).map_err(|_| {\n                std::io::Error::new(\n                    ErrorKind::InvalidData,\n                    \"Couldn't decode length-delimited data\",\n                )\n            })? {\n                Some(frame) =&gt; frame,\n                None =&gt; return Ok(None), // Not enough data yet\n            };\n\n            let (message, _) = bincode::decode_from_slice(&amp;frame, self.config).map_err(|_| {\n                std::io::Error::new(\n                    ErrorKind::InvalidData,\n                    \"Couldn't decode message from bitcode\",\n                )\n            })?;\n\n            Ok(Some(message))\n        }\n    }\n}\n</code></pre></p> <ol> <li> <p>Remember that we need to return the code as a TokenStream. <code>quote</code> provides a very handy macro that takes in a rust looking template and produces a valid Rust TokenStream.</p> </li> <li> <p><code>quote</code> will replace this with the codec name.</p> </li> <li> <p><code>quote</code> will replace this with the message name.</p> </li> </ol> <p>Thats it!!!.</p>","tags":["rust"]},{"location":"blog/2024/12/21/my-first-rust-macro/#usage","title":"Usage","text":"<p>Now that we have implemented our derive_macro we can use it as follows:- <pre><code>#[derive(Debug, PartialEq, Eq, Clone, Encode, Decode, Codec)]\npub enum FromCoordToWorker {\n    Done,\n    PollTPRequest(u64),\n    Reconf(Box&lt;ReconfMsg&gt;),\n    Exit,\n}\n</code></pre> Now when we create a new message we just need to add <code>#[derive(Codec)]</code> and we will have a codec generated for that message. Note that it is required that message also implements <code>Encode</code> and <code>Decode</code> in order to derive a Codec.</p>","tags":["rust"]},{"location":"blog/2024/12/13/how-to-measure-latency-in-data-streaming-systems/","title":"How to measure latency in data streaming systems?","text":""},{"location":"blog/2024/12/13/how-to-measure-latency-in-data-streaming-systems/#introduction","title":"Introduction","text":"<p>Measuring latency in batch processing is trivial.</p>"},{"location":"blog/2024/12/13/how-to-measure-latency-in-data-streaming-systems/#references","title":"References","text":"<ol> <li>Benchmarking Distributed Stream Data Processing Systems</li> </ol>"},{"location":"blog/2024/12/09/reading-list-research-papers/","title":"Reading list (Research Papers)","text":"<p>List of important research papers.</p> <ol> <li>Google Dataflow</li> <li>Timely Dataflow</li> </ol>"},{"location":"blog/2024/12/08/reading-listtechnical-articles/","title":"Reading list(Technical articles)","text":"<p>List of key articles/videos that enhanced my understanding of computer science topics.</p> <ul> <li>Git, first principle</li> <li>Rust async, first principle</li> <li>Rust testing</li> <li>Latency and Throughtput</li> </ul>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/category/dev-diary/","title":"dev-diary","text":""},{"location":"blog/category/system/","title":"system","text":""},{"location":"blog/category/streaming/","title":"streaming","text":""},{"location":"blog/category/latency/","title":"latency","text":""},{"location":"blog/category/article/","title":"article","text":""},{"location":"blog/category/list/","title":"list","text":""},{"location":"blog/category/paper/","title":"paper","text":""}]}